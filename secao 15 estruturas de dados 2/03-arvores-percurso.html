<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Estruturas de Dados 2 - Árvores</title>
    </head>
    <body>
        
        <h1>Percursos - Pré-order, in-order e pós-order</h1>

        <p>
            O que vem a ser percursos? Percurso nada mais é do que uma maneira de percorrer de fato <br>
            todos os nós de uma árvore.
        </p>
        <p>
            Quase sempre será necessário executar alguma função em cada nó de uma árvore. Mas por onde iniciar <br>
            esse percurso? Da esquerda para a direita ou da direita para a esquerda? Qual seria a ordem para percorrer <br>
            todos os nós dessa árvore?
        </p>
        <p>
            Temos três maneiras de fazer esse tipo de navegação entre os nós de uma árvore: <br>
            <strong>→ Pré-order</strong> | <strong>→ In-order</strong> | <strong>→ Pós-order</strong> <br>
        </p>
        <p>
            Existem mais algumas opções, mas estas três são as mais utilizadas.
        </p> <br><hr>

        <h3>Percurso Pré-Order:</h3>
        <img src="imgs/percurso-pre-order.png" alt=""> <br><br>

        <h3>Percurso In-Order:</h3>
        <img src="imgs/percurso-in-order.png" alt=""> <br><br>

        <h3>Percurso Pós-Order:</h3>
        <img src="imgs/percurso-pos-order.png" alt=""> <br><br>

        <h3>Comparando os três</h3>
        <img src="imgs/percurso-comparando-tres.png" alt="">
        
        

        <script>
            
            class Node{
                constructor(key){
                    this.key = key
                    this.left = null
                    this.right = null
                }
            }
            class BinarySearchTree{
                constructor(){
                    this.root = null
                }
                insert(key){
                    const newNode = new Node(key)

                    if(this.root === null){
                        this.root = newNode
                    } else{
                        this.#insertNode(this.root, newNode)
                    }
                }

                #insertNode(node, newNode){
                    if(newNode.key < node.key){
                        if(node.left === null){
                            node.left = newNode
                        } else{
                            this.#insertNode(node.left, newNode)
                        }
                    } else if(newNode.key > node.key){
                        if(node.right === null){
                            node.right = newNode
                        } else{
                            this.#insertNode(node.right, newNode)
                        }
                    }
                }

                search(key){
                    return this.#searchNode(this.root, key)
                }

                #searchNode(node, key){
                    if(node === null){
                        return false
                    }

                    if(key < node.key){
                        return this.#searchNode(node.left, key)
                    } else if(key > node.key){
                        return this.#searchNode(node.right,key)
                    } else{
                        return true
                    }
                }

                remove(key){
                    this.root = this.#removeNode(this.root, key)
                }

                #removeNode(node, key){
                    if(node === null){
                        return null
                    }

                    if(key < node.key){
                        node.left = this.#removeNode(node.left, key)
                        return node
                    } else if(key > node.key){
                        node.right = this.#removeNode(node.right, key)
                        return node
                    } else{
                        // nó folha
                        if(node.left === null && node.right === null){
                            node = null
                            return node
                        }

                        // nó com 1 filho
                        if(node.left === null){
                            node = node.right
                            return node
                        } else if(node.right === null){
                            node = node.left
                            return node
                        }

                        // nó com 2 filhos
                        const aux = this.#findMinNode(node.right)
                        node.key = aux.key
                        node.right = this.#removeNode(node.right, aux.key)
                        return node

                    }
                }

                #findMinNode(node){
                    while(node && node.left !== null){
                        node = node.left
                    }
                }
            }

            const bst = new BinarySearchTree()
            bst.insert(20)
            bst.insert(15)
            bst.insert(18)
            bst.insert(15)
            bst.insert(10)
            bst.insert(25)

            console.log('buscando o número 1', bst.search(1))   // vai retornar 'false'
            //console.log('removendo o número 1', bst.remove(1))  // null

            bst.remove(1)
            console.log(bst)
            bst.remove(10)
            console.log(bst)
        </script>

    </body>
</html>